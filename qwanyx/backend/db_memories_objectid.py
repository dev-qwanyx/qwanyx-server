"""
Memory persistence for QWANYX dashboard using ObjectId as primary identifier
Follows the architecture where _id IS our UUID
"""

from pymongo import MongoClient
from bson import ObjectId
from datetime import datetime
import os

# MongoDB connection
MONGO_URI = os.getenv('MONGO_URI', 'mongodb://localhost:27017/')
client = MongoClient(MONGO_URI)

def get_user_database(workspace, user_email):
    """Get database for a specific workspace and user"""
    # MongoDB doesn't allow dots in database names, use underscores
    # Convert email to safe format: test@qwanyx.com -> test_at_qwanyx_com
    safe_email = user_email.replace('@', '_at_').replace('.', '_')
    db_name = f"{workspace}_users_{safe_email}"
    db = client[db_name]
    
    # Ensure indexes for performance
    db['memories'].create_index("p")  # Parent index
    db['memories'].create_index("type")
    db['memories'].create_index("deleted")
    db['memories'].create_index([("from", 1), ("to", 1)])  # Compound for messages
    
    return {
        'memories': db['memories'],
        'edges': db['edges'],
        'qwanyx.identity': db['qwanyx.identity'],
        'qwanyx.profile': db['qwanyx.profile'],
        'qwanyx.preferences': db['qwanyx.preferences'],
        'qwanyx.firmware': db['qwanyx.firmware'],
        'qwanyx.connections': db['qwanyx.connections'],
        'qwanyx.lineage': db['qwanyx.lineage']
    }

def create_memory(workspace, user_email, memory_type, title=None, parent_id=None, icon=None, content=None):
    """Create a new memory (column or card)"""
    db = get_user_database(workspace, user_email)
    memories = db['memories']
    
    # Convert parent_id string to ObjectId if provided
    parent_oid = ObjectId(parent_id) if parent_id else None
    
    memory = {
        # _id will be auto-generated by MongoDB
        'p': parent_oid,  # Parent ObjectId
        'type': memory_type,  # 'column' or 'card'
        'title': title or '',
        'brief': '',
        'icon': icon,
        'content': content or {},
        'deleted': False,
        'deletedAt': None
        # No created field - use _id.getTimestamp()
        # No uuid field - _id IS our UUID
    }
    
    result = memories.insert_one(memory)
    memory['_id'] = result.inserted_id
    
    return serialize_memory(memory)

def get_user_dashboard(workspace, user_email):
    """Get all columns and cards for a user's dashboard"""
    db = get_user_database(workspace, user_email)
    memories = db['memories']
    
    # Get root columns (no parent) - exclude deleted
    columns = list(memories.find({
        'type': 'column',
        'p': None,  # Root level columns
        'deleted': False
    }))
    
    # Get all cards for each column
    for column in columns:
        column['cards'] = list(memories.find({
            'type': 'card',
            'p': column['_id'],
            'deleted': False
        }))
        # Serialize cards
        column['cards'] = [serialize_memory(card) for card in column['cards']]
        
        # Get nested columns
        column['nested_columns'] = list(memories.find({
            'type': 'column',
            'p': column['_id'],
            'deleted': False
        }))
        # Recursively get cards for nested columns
        for nested in column['nested_columns']:
            nested['cards'] = list(memories.find({
                'type': 'card',
                'p': nested['_id'],
                'deleted': False
            }))
            nested['cards'] = [serialize_memory(card) for card in nested['cards']]
        column['nested_columns'] = [serialize_memory(nc) for nc in column['nested_columns']]
    
    return [serialize_memory(col) for col in columns]

def update_memory(workspace, user_email, memory_id, updates):
    """Update a memory"""
    db = get_user_database(workspace, user_email)
    memories = db['memories']
    
    memory_oid = ObjectId(memory_id)
    
    # Remove _id from updates if present
    updates.pop('_id', None)
    updates.pop('id', None)
    
    # Convert parent reference to ObjectId if present
    if 'p' in updates and updates['p']:
        updates['p'] = ObjectId(updates['p'])
    
    memories.update_one(
        {'_id': memory_oid},
        {'$set': updates}
    )
    
    return True

def move_memory(workspace, user_email, memory_id, new_parent_id):
    """Move a memory to a new parent (column or position)"""
    db = get_user_database(workspace, user_email)
    memories = db['memories']
    
    memory_oid = ObjectId(memory_id)
    new_parent_oid = ObjectId(new_parent_id) if new_parent_id else None
    
    memories.update_one(
        {'_id': memory_oid},
        {'$set': {'p': new_parent_oid}}
    )
    
    return True

def soft_delete_memory(workspace, user_email, memory_id):
    """Soft delete a memory and all its children"""
    db = get_user_database(workspace, user_email)
    memories = db['memories']
    
    memory_oid = ObjectId(memory_id)
    
    # Find all children recursively
    def get_descendants(parent_oid):
        children = list(memories.find({'p': parent_oid, 'deleted': False}))
        descendants = []
        for child in children:
            descendants.append(child['_id'])
            descendants.extend(get_descendants(child['_id']))
        return descendants
    
    # Soft delete the memory and all descendants
    to_delete = [memory_oid] + get_descendants(memory_oid)
    
    # Mark memories as deleted
    memories.update_many(
        {'_id': {'$in': to_delete}},
        {'$set': {
            'deleted': True,
            'deletedAt': datetime.utcnow()
        }}
    )
    
    return True

def serialize_memory(memory):
    """Convert memory for frontend consumption"""
    if not memory:
        return None
    
    # Convert ObjectId to string for JSON serialization
    result = dict(memory)
    result['id'] = str(memory['_id'])  # Frontend uses 'id'
    del result['_id']  # Remove MongoDB _id
    
    # Convert parent ObjectId to string if exists
    if result.get('p'):
        result['p'] = str(result['p'])
    
    # Add creation timestamp from ObjectId
    result['created'] = ObjectId(memory['_id']).generation_time.isoformat()
    
    return result

def get_or_create_user_identity(workspace, user_email):
    """Get or create user identity in qwanyx.identity collection"""
    db = get_user_database(workspace, user_email)
    identity_col = db['qwanyx.identity']
    
    # Check if identity exists
    identity = identity_col.find_one({'current_email': user_email})
    
    if not identity:
        # Create new identity
        identity = {
            'current_email': user_email,
            'previous_emails': [],
            'workspace': workspace,
            'type': 'user'
        }
        result = identity_col.insert_one(identity)
        identity['_id'] = result.inserted_id
    
    return str(identity['_id'])